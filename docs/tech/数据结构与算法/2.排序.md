# 排序
## 选择排序
首先，找到数组中最小元素，然后将它和数组的第一个元素交换位置。之后在剩下元素中找到最小元素，将它与数组的第二个元素交换位置，循环往复，直到将整个数组排序。

选择排序有两层循环，事件复杂度为 O(n<sup>2</sup>)。
1. 第一层从左至右
2. 第二层从当前索引向后
    2.1 寻找最小的元素
    2.2 将最小元素与当前元素的位置进行调换

```js
sort(arr) {
    let n = arr.length
    for (let i = 0; i < n; i++) {
        // 寻找剩余元素里最小值的索引，如果当前值已经是最小的，则交换其自身
        let minIndex = i
        for (let j = i + 1; j < n; j++) {
            if (this.less(arr[j], arr[i])) minIndex = j
        }
        this.exch(i, minIndex)
    }
}
```
## 插入排序
两层循环，从左起依次将左边的元素排好序。

第一个元素默认是有序的，从左起第二个元素开始，比较其与左边第一个元素的大小，如果小于第一个元素，则交换之。

这样依次遍历，当前元素左侧的部分永远是有序的。只需要把当前元素交换到左侧合适的位置（其左侧不小于它时停下），保证左侧始终有序。

```js
sort(arr) {
    let n = arr.length
    for (let i = 1; i < n; i++) {
        // 将右边新增的元素移动至左子集里合适的位置
        for (let j = i; j > 0; j--) {
            // 如果右值不小于左值，跳出循环（因为左边已经是有序的，右值不小于左值则不可能小于更左边的元素）
            if (!this.less(arr[j], arr[j - 1])) break;
            // 交换相邻元素
            this.exch(arr, j, j - 1)
        }
    }
}
```

## 希尔排序
对普通插入排序只能移动相邻元素的缺点进行优化，能够交换不相邻的元素以对数组的局部进行排序。其核心思想是<mark>使得数组中任意间隔为 h 的元素都是有序的。</mark>

> 一个 h 有序的数组就是 h 个互相独立的有序数组编织在一起组成的一个数组。

希尔排序更高效的原因是它权衡了子数组的**规模**和**有序性**。

```js
sort(arr) {
    let n = arr.length
    let h = 1
    // 计算 h 值
    while (h < Math.floor(n / 3)) h = 3 * h + 1
    // 在插入排序的基础上加入一个外循环将 h 按递增序列递减
    while (h >= 1) {
        // 内循环是以 h 为间隔的插入排序
        // 1. 从第 h 个向后所有元素（类似插入排序中的第 1 个元素）
        for (let i = h; i < n; i++) {
            // 2. 与当前元素间隔 h 的子元素组
            for (let j = i; j >= h; j -= h) {
                // 把当前元素插入到合适的位置后，退出循环
                if (!this.less(arr[j], arr[j - h])) break;

                // 交换以保证左侧有序
                this.exch(arr, j, j - h)
            }
        }
        h = Math.floor(h / 3)
    }
}
```
## 归并排序
思想：要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。

归并算法如下，它提供一种将有序的两个子数组，按照顺序合并为一个数组的方式:
```js
function merge(arr, low, mid, hi) {
    // 0. 创建左右子数组的指针
    let i = low, j = mid + 1
    // 1. 使用辅助函数，记录当前需要排序的元素（不用复制所有 arr）
    const aux = []
    for (let k = low; k <= hi; k++) {
        aux[k] = arr[k]
    }

    // 2. 比较左右子数组的大小，选择第 k 个元素从哪边取
    for (let k = low; k <= hi; k++) {
        /* 
            从正常理解的思路，是先写了左右元素的判断逻辑，然后再做边界判断；
            但执行时，需要把边界判断写在前面；
         */
        // 边界处理
        if (i > mid) {
            arr[k] = aux[j++]
        } else if (j > hi) {
            arr[k] = aux[i++]
        }
        // 判断左右半边的元素，选择较小的放在正确位置
        else if (aux[i] <= aux[j]) {
            arr[k] = aux[i++]
        } else {
            arr[k] = aux[j++]
        }
    }
}
```
