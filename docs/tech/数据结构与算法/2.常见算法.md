# 常用算法
## 排序
### 初级排序
#### 选择排序
首先，找到数组中最小元素，然后将它和数组的第一个元素交换位置。之后在剩下元素中找到最小元素，将它与数组的第二个元素交换位置，循环往复，直到将整个数组排序。

选择排序有两层循环，事件复杂度为 O(n<sup>2</sup>)。
1. 第一层从左至右
2. 第二层从当前索引向后
    2.1 寻找最小的元素
    2.2 将最小元素与当前元素的位置进行调换

```js
sort(arr) {
    let n = arr.length
    for (let i = 0; i < n; i++) {
        // 寻找剩余元素里最小值的索引，如果当前值已经是最小的，则交换其自身
        let minIndex = i
        for (let j = i + 1; j < n; j++) {
            if (this.less(arr[j], arr[i])) minIndex = j
        }
        this.exch(i, minIndex)
    }
}
```
#### 插入排序
两层循环，从左起依次将左边的元素排好序。

第一个元素默认是有序的，从左起第二个元素开始，比较其与左边第一个元素的大小，如果小于第一个元素，则交换之。

这样依次遍历，当前元素左侧的部分永远是有序的。只需要把当前元素交换到左侧合适的位置（其左侧不小于它时停下），保证左侧始终有序。

```js
sort(arr) {
    let n = arr.length
    for (let i = 1; i < n; i++) {
        // 将右边新增的元素移动至左子集里合适的位置
        for (let j = i; j > 0; j--) {
            // 如果右值不小于左值，跳出循环（因为左边已经是有序的，右值不小于左值则不可能小于更左边的元素）
            if (!this.less(arr[j], arr[j - 1])) break;
            // 交换相邻元素
            this.exch(arr, j, j - 1)
        }
    }
}
```

#### 希尔排序
对普通插入排序只能移动相邻元素的缺点进行优化，能够交换不相邻的元素以对数组的局部进行排序。其核心思想是<mark>使得数组中任意间隔为 h 的元素都是有序的。</mark>

> 一个 h 有序的数组就是 h 个互相独立的有序数组编织在一起组成的一个数组。

希尔排序更高效的原因是它权衡了子数组的**规模**和**有序性**。

```js
sort(arr) {
    let n = arr.length
    let h = 1
    // 计算 h 值
    while (h < Math.floor(n / 3)) h = 3 * h + 1
    // 在插入排序的基础上加入一个外循环将 h 按递增序列递减
    while (h >= 1) {
        // 内循环是以 h 为间隔的插入排序
        // 1. 从第 h 个向后所有元素（类似插入排序中的第 1 个元素）
        for (let i = h; i < n; i++) {
            // 2. 与当前元素间隔 h 的子元素组
            for (let j = i; j >= h; j -= h) {
                // 把当前元素插入到合适的位置后，退出循环
                if (!this.less(arr[j], arr[j - h])) break;

                // 交换以保证左侧有序
                this.exch(arr, j, j - h)
            }
        }
        h = Math.floor(h / 3)
    }
}
```
### 归并排序
思想：要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。

归并算法如下，它提供一种将有序的两个子数组，按照顺序合并为一个数组的方式:
```js
function merge(arr, low, mid, hi) {
    // 0. 创建左右子数组的指针
    let i = low, j = mid + 1
    // 1. 使用辅助函数，记录当前需要排序的元素（不用复制所有 arr）
    const aux = []
    for (let k = low; k <= hi; k++) {
        aux[k] = arr[k]
    }

    // 2. 比较左右子数组的大小，选择第 k 个元素从哪边取
    for (let k = low; k <= hi; k++) {
        /* 
            从正常理解的思路，是先写了左右元素的判断逻辑，然后再做边界判断；
            但执行时，需要把边界判断写在前面；
         */
        // 边界处理
        if (i > mid) {
            arr[k] = aux[j++]
        } else if (j > hi) {
            arr[k] = aux[i++]
        }
        // 判断左右半边的元素，选择较小的放在正确位置
        else if (aux[i] <= aux[j]) {
            arr[k] = aux[i++]
        } else {
            arr[k] = aux[j++]
        }
    }
}
```

#### 自顶向下
自顶向下的归并排序是先将数组递归地分到最后左右半边都只有一个元素，然后将这两个元素排序，再向上一级级地返回结果。

这是一种分治思想：<mark>将大问题分割成小问题分别解决，然后使用所有小问题的答案来解决整个大问题。</mark>

```js
function sort(arr, low, hi) {
    // 0. 第一次未传 low 和 hi 的参数，设置初始化
    if (low === undefined) low = 0;
    if (hi === undefined) hi = arr.length - 1

    // 1. 递归出口：当切分到只有一个元素
    if (low >= hi) return;

    // 2. 切分
    // 2.1 寻找中间点
    let mid = Math.floor((low + hi) / 2)
    // 2.2 将左半边递归排序
    sort(arr, low, mid)
    // 2.3 将右半边递归排序
    sort(arr, mid + 1, hi)

    /* 优化:当数组已经有序时,不必进行 merge 操作 */
    if (arr[mid] <= arr[mid + 1]) return;

    // 2.4 归并左右半边的结果
    merge(arr, low, mid, hi)
}
```

#### 自底向上
自底向上的归并排序是先归并微型数组，然后再成对归并得到的子数组，直到将整个数组归并在一起。

从一一归并，然后二二归并，然后四四归并，直到整个数组被归并，有点类似希尔排序。（感觉）

```js
function sort(arr) {
    const n = arr.length
    const aux = new Array(n)
    // 外层循环从 1 -> 2 -> 4 -> 8 -> ... -> n
    for (let size = 1; size < n; size = size * 2) {
        // 内层循环：0 -> 0 + 2*sz -> 0 + 4 * sz -> ... -> n - sz

        // 为什么以 n - size 为限制
        for (let low = 0; low < n - size; low += size * 2) {
            merge(arr, low, low + size - 1, Math.min(low + size + size - 1, n - 1)/* 最后一个右子数组长度很可能小于左子数组 */)
        }
    }
}
```

### 快速排序
快排是一种分治的排序算法，它将一个数组分成两个子数组，将两部分各自独立排序。

归并排序是将数组分成两个数组分别排序，将有序子数组归并以将整个数组排序；而快排是当两个子数组都有序时，整个数组就自然有序了。

快排方法的关键在于切分，切分过程总能排定一个元素。

```js
function sort(arr, low, high) {
    if (low === undefined) {
        // 打乱数组
        arr.sort(() => Math.random() - 0.5)
        low = 0;
        high = arr.length - 1;
    }

    if (low >= high) return;
    let j = partition(arr, low, high)
    sort(arr, low, j - 1)
    sort(arr, j, high)
}

// 切分算法
function partition(arr, low, high) {
    let i = low, j = high + 1
    let v = arr[low]
    while (true) {
        while (arr[++i] < v) {
            if (i === high) break;
        }
        while (v < arr[--j]) {
            if (j === low) break;
        }

        if (i >= j) break;
        [arr[i], arr[j]] = [arr[j], arr[i]]
    }
    [arr[low], arr[j]] = [arr[j], v]
    return j
}
```

#### 三向切分（对于重复数据多的数组的排序方案）
```js
function sort(arr, low, high) {
    if (low === undefined) {
        // 打乱数组
        arr.sort(() => Math.random() - 0.5)
        low = 0;
        high = arr.length - 1;
    }

    if (high <= low) return;
    
    let {left, right} = partition(arr, low, right)

    sort(arr, low, left - 1)
    sort(arr, right + 1, high)
}

function partition(arr, low, high) {
    let left = low, i = low + 1, right = high
    let v = arr[low]

    while (i <= right) {
        if (arr[i] < v) {
            [arr[left], arr[i]] = [arr[i], arr[left]]
            left++
            i++
        } else if (arr[i] > v) {
            [arr[i], arr[right]] = [arr[right], arr[i]]
            right--
        } else {
            i++
        }
    }

    return {left, right}
}
```
### 最大堆/最小堆
最大堆和最小堆都是使用数组对数据进行存储。

维护一个数组，和元素个数计数器。

**数组映射到完全二叉树**

其被看作是一棵完全二叉树，元素在二叉树中的位置通过数组下标计算而来，如对于索引为 k 的非根节点：
- 其父节点索引为 `Math.floor(k / 2)`
- 其子节点索引为 `2k` 和 `2k + 1` 

这样就通过数组下标实现在二叉树中的上下移动。

> 堆算法中，一般 pq[0] 不使用，因为要维护元素计数器 N ，当从索引 1 开始存储数据时， N 和数组长度就能够对应，而无需额外 -1 ，方便编写。

**元素的上浮和下沉**

该树是一个堆有序的结构，保证父节点是其所有子节点中的最值（最大堆中，父节点是其所有子节点中最大的，而根节点则是该数组的最大元素；最小堆也类似）。

这种保证是通过对元素进行下沉或上浮来实现的。

```js
// 上浮操作：让元素向上移动到合适的位置，从队尾向队首靠拢，直到停在上不去的地方
function swim(k) {
    /* pq 索引是从 1 开始存数据，这里的判断是当元素为根节点时，跳出循环 */
    while (k > 1 ) {
        // 获取元素的父节点索引
        const parent = Math.floor(k / 2)
        // 如果父节点的值小于 k 节点（针对最大堆）
        if (less(parent, k)) {
            // 交换父节点和 k 节点的值
            exch(parent, k)
            // 指针指向 k 现在的位置，继续上浮
            k = parent
        } else break; // 没干过父节点，老实待着
    }
}

// 下沉操作，让元素下沉到合适的位置，队首 -> 队尾
function sink(k) {
    // 当元素的子节点索引在元素个数范围内（确保 k 节点有子节点）
    while (2 * k <= N) {
        // 获取左子节点索引
        let child = 2 * k
        // 如果有右节点，且右节点值更大(针对最大堆)
        if (child < N && less(child, child + 1)) {
            // 更新子节点比较对象（父节点要干就干最牛逼的孩子）
            child++
        }
        // 没干过，愿赌服输，与子节点交换位置，真~父子局
        if (less(k, child)) {
            exch(k, child)
            // 更新 k 节点位置，继续下沉
            k = child
        } else break; // 父节点比子节点厉害，那就不用动了
    }
}
```

**处理新增**

1. 将其推入数组末尾
2. 对其进行上浮操作，恢复堆的有序性

**处理删除最大值**

1. 将最大值与数组末尾值交换
2. 数组长度减 1 （因为最大值要被删除，它留在队尾会影响下沉操作）
3. 让队首的值（即前数组末尾值，因为它必然是相对较小的值）下沉
4. 返回缓存的最大值

#### 以最大堆为例
```js
class MaxPQ {
    constructor() {
        this.pq = []
        // this.N = 0
    }

    insert(item) {
        // this.pq[++this.N] = item
        this.pq.push(item)
        this.swim(this.pq.length - 1)
    }

    size() {
        return this.pq.length
    }

    max() {
        return this.pq[0]
    }

    deleteMax() {
        const max = this.max()
        this.pq[0] = this.pq.pop()
        this.sink(0)
        return max
    }

    swim(k) {
        while (k > 0) {
            const parent = Math.floor(k / 2)
            if (this.less(parent, k)) {
                this.exch(parent, k)
                k = parent
            } else break;
        }
    }

    sink(k) {
        while (k * 2 < this.pq.length) {
            let child = k * 2
            if (child + 1 < this.pq.length && this.less(child, child + 1)) child++;
            if (this.less(k, child)) {
                this.exch(k, child)
                k = child
            } else break;
        }
    }

    exch(i, j) {
        let temp = this.pq[i]
        this.pq[i] = this.pq[j]
        this.pq[j] = temp
    }

    less(i, j) {
        return this.pq[i] < this.pq[j]
    }
}
```
### 索引优先队列


## 查找
### 二分查找

### DFS

### BFS

### 滑动窗口

### 并查集

## 图 
### 无向图

### 有向图

### 最小生成树

### 最短路径

## 字符串
### 排序

### 查找

### 子字符串

### 正则