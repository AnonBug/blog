# 二叉树
## 运用递归解决树的问题

> [leetcode book](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xefb4e/)

树可以以递归的方式定义为一个节点（根节点），它包括一个值和一个指向其他节点指针的列表。 递归是树的特性之一。 因此，许多树问题可以通过递归的方式来解决。 

**对于每个递归层级，我们只能关注单个节点内的问题，并通过递归调用函数来解决其子节点问题。**

通常，我们可以通过 “自顶向下” 或 “自底向上” 的递归来解决树问题。

### 自顶向下

自顶向下首先访问节点，计算一些值，然后递归调用，将这些值传递给子节点。可看作是**前序遍历**的一种方式。

```js
// 以计算树的节点深度为例
function top_down(node, params) {
    // 1. 当节点为空时，结束递归
    if (!node) return;
    // 2. 当节点满足某个条件时，使用 params 更新答案
    if (!node.left && !node.right) {
        ans = Math.max(ans, params)
    }
    // 3. 左子树递归，并传入更新参数
    let left_answer = top_down(node.left, params + 1)
    // 4. 右子树递归，并传入更新参数
    let right_answer = top_down(node.right, params + 1)
}
```

在第二步更新答案中，更新的是外部变量。

### 自底向上
在每个递归层次上，我们首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案。 这个过程可以看作是**后序遍历**的一种。


```js
// 以计算树的节点深度为例
function bottom_up(node) {
    // 1. 当节点为空时，返回某个具体值
    if (!node) return 0;
    // 2. 左子树递归，并传入更新参数
    let left_answer = bottom_up(node.left)
    // 3. 右子树递归，并传入更新参数
    let right_answer = bottom_up(node.right)
    // 4. 根据子节点的答案，计算根节点
    return Math.max(left_answer, right_answer) + 1
}
```

### 何时选择何种方式

#### 二者区别

- 自顶向下需要往子节点传参，自底向上不需要传参
- 自顶向下更新的答案是外部变量，自底向上是根据子节点答案计算根节点，直接返回答案

#### 判断

当遇到树问题时，请先思考一下两个问题：

- 你能确定一些参数，从该节点自身解决出发寻找答案吗？
- 你可以使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数吗？

如果答案都是肯定的，那么请尝试使用 “自顶向下” 的递归来解决此问题。

---

或者你可以这样思考：

- 对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出该节点的答案吗？ 

如果答案是肯定的，那么 “自底向上” 的递归可能是一个不错的解决方法。
