(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{485:function(t,s,a){t.exports=a.p+"assets/img/数据链路层.6533c917.png"},486:function(t,s,a){t.exports=a.p+"assets/img/封装成帧.38a38deb.png"},487:function(t,s,a){t.exports=a.p+"assets/img/差错检测算法.91aaaeeb.png"},488:function(t,s,a){t.exports=a.p+"assets/img/可靠传输.6cb5b99e.png"},489:function(t,s,a){t.exports=a.p+"assets/img/可靠传输-基本概念.2838d8f4.png"},490:function(t,s,a){t.exports=a.p+"assets/img/停止-等待协议.e92f458d.png"},491:function(t,s,a){t.exports=a.p+"assets/img/回退N帧协议.9bb294a6.png"},492:function(t,s,a){t.exports=a.p+"assets/img/选择重传协议.5e4288e7.png"},722:function(t,s,a){"use strict";a.r(s);var _=a(26),r=Object(_.a)({},(function(){var t=this,s=t.$createElement,_=t._self._c||s;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"数据链路层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据链路层"}},[t._v("#")]),t._v(" 数据链路层")]),t._v(" "),_("h2",{attrs:{id:"_1-概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述"}},[t._v("#")]),t._v(" 1. 概述")]),t._v(" "),_("p",[_("img",{attrs:{src:a(485),alt:""}})]),t._v(" "),_("h2",{attrs:{id:"_2-封装成帧"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-封装成帧"}},[t._v("#")]),t._v(" 2. 封装成帧")]),t._v(" "),_("p",[t._v("数据链路层为上层交付的数据单元添加 帧头 和 帧尾，使数据包能够以 帧 为单元进行数据传输。\n"),_("img",{attrs:{src:a(486),alt:""}})]),t._v(" "),_("ul",[_("li",[t._v("帧头和帧尾中有重要的控制信息")]),t._v(" "),_("li",[t._v("帧尾封装错误检测码")]),t._v(" "),_("li",[t._v("帧头和帧尾包含 1 个字节的标志位（可能，MAC 帧由物理层添加前导码，不需要标志位）")])]),t._v(" "),_("h3",{attrs:{id:"_2-1-透明传输"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-透明传输"}},[t._v("#")]),t._v(" 2.1 透明传输")]),t._v(" "),_("p",[t._v("透明传输指数据链路层对上层交付的数据单元不做任何限制，好像链路层不存在一样。")]),t._v(" "),_("p",[t._v("实现的"),_("strong",[t._v("难点在于当数据单元中出现与帧头或帧尾相同的字节时，接收方有可能产生误判")]),t._v("。")]),t._v(" "),_("p",[t._v("为了消弭这种误判，针对不同的物理链路，有不同的处理方式：")]),t._v(" "),_("ol",[_("li",[t._v("面向字节的物理链路\n"),_("ul",[_("li",[t._v("使用字节填充法（使用转义字节对数据单元中"),_("strong",[t._v("与帧数据或转义字节相同的部分")]),t._v("进行转义）")])])]),t._v(" "),_("li",[t._v("面向比特的物理链路\n"),_("ul",[_("li",[t._v("使用比特填充法（每 5 个连续的 1 后面追加一个 0）")])])])]),t._v(" "),_("h2",{attrs:{id:"_3-差错检测"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-差错检测"}},[t._v("#")]),t._v(" 3. 差错检测")]),t._v(" "),_("p",[t._v("数据帧在传输过程中可能出现误码（0 变成 1）。")]),t._v(" "),_("p",[t._v("为进行错误检测，链路层在发送帧数据之前，对数据包进行计算生成检错码，封装在 帧尾。接收方同样对数据包执行检测算法，生成的检错码与帧尾对比。")]),t._v(" "),_("h3",{attrs:{id:"_3-1-检错算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-检错算法"}},[t._v("#")]),t._v(" 3.1 检错算法")]),t._v(" "),_("p",[t._v("检测算法为一个特定的多项式。具体计算过程如下：")]),t._v(" "),_("p",[_("img",{attrs:{src:a(487),alt:""}})]),t._v(" "),_("h2",{attrs:{id:"_4-可靠传输"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-可靠传输"}},[t._v("#")]),t._v(" 4. 可靠传输")]),t._v(" "),_("p",[t._v("接收方收到有误码的帧后，会将其丢弃。")]),t._v(" "),_("p",[t._v("除了误码，传输差错还包括分组丢失，分组失序，分组重复。")]),t._v(" "),_("h3",{attrs:{id:"_4-1-基本概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-基本概念"}},[t._v("#")]),t._v(" 4.1 基本概念")]),t._v(" "),_("p",[_("strong",[t._v("误码无法避免，但只要能够保证发送方发送什么，接收方就能接到什么，就称其为可靠传输。")])]),t._v(" "),_("p",[_("img",{attrs:{src:a(488),alt:""}})]),t._v(" "),_("p",[_("img",{attrs:{src:a(489),alt:""}})]),t._v(" "),_("h3",{attrs:{id:"_4-2-停止-等待协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-停止-等待协议"}},[t._v("#")]),t._v(" 4.2 停止-等待协议")]),t._v(" "),_("p",[_("img",{attrs:{src:a(490),alt:""}})]),t._v(" "),_("h3",{attrs:{id:"_4-3-回退-n-帧协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-回退-n-帧协议"}},[t._v("#")]),t._v(" 4.3 回退 N 帧协议")]),t._v(" "),_("p",[_("img",{attrs:{src:a(491),alt:""}})]),t._v(" "),_("h3",{attrs:{id:"_4-4-选择重传协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-选择重传协议"}},[t._v("#")]),t._v(" 4.4 选择重传协议")]),t._v(" "),_("p",[_("img",{attrs:{src:a(492),alt:""}})])])}),[],!1,null,null,null);s.default=r.exports}}]);