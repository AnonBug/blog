(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{475:function(_,v,t){_.exports=t.p+"assets/img/短连接.019a1062.png"},476:function(_,v,t){_.exports=t.p+"assets/img/HTTP_Request.d2fb5602.png"},477:function(_,v,t){_.exports=t.p+"assets/img/HTTP_Response.94e095a3.png"},478:function(_,v,t){_.exports=t.p+"assets/img/HTTP_Cache.8ff71286.png"},479:function(_,v,t){_.exports=t.p+"assets/img/cache-control与expires.5083dde7.png"},480:function(_,v,t){_.exports=t.p+"assets/img/https通信过程.88753ddd.png"},481:function(_,v,t){_.exports=t.p+"assets/img/根证书.4fd5df46.png"},482:function(_,v,t){_.exports=t.p+"assets/img/中级证书.40886765.png"},483:function(_,v,t){_.exports=t.p+"assets/img/SSL证书.672b223e.png"},484:function(_,v,t){_.exports=t.p+"assets/img/http3与http2.10c3b8ef.png"},721:function(_,v,t){"use strict";t.r(v);var e=t(26),s=Object(e.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"http-系列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-系列"}},[_._v("#")]),_._v(" HTTP 系列")]),_._v(" "),e("p",[_._v("HTTP 是应用层非常重要的协议，应用层服务架构分为以下两种：")]),_._v(" "),e("h2",{attrs:{id:"_1-http-1-1-协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-http-1-1-协议"}},[_._v("#")]),_._v(" 1. HTTP/1.1 协议")]),_._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP",target:"_blank",rel:"noopener noreferrer"}},[_._v("HTTP教程 —— MDN"),e("OutboundLink")],1)])]),_._v(" "),e("p",[_._v("超文本传输协议是用于"),e("strong",[_._v("传输超媒体文档")]),_._v("的应用层协议，服务于 Web 浏览器与 Web 服务器之间的通信，遵循经典 "),e("code",[_._v("C/S")]),_._v(" 架构，客户端打开一个连接以发送请求，然后等待服务器的响应。"),e("strong",[_._v("HTTP 是一种无状态协议，服务器在两次请求之间不会保留任何数据。")])]),_._v(" "),e("h3",{attrs:{id:"_1-1-http-会话过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-http-会话过程"}},[_._v("#")]),_._v(" 1.1 HTTP 会话过程")]),_._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Session",target:"_blank",rel:"noopener noreferrer"}},[_._v("典型的 HTTP 会话——MDN"),e("OutboundLink")],1)])]),_._v(" "),e("p",[_._v("客户端想要与服务端进行信息交互时有以下几步：")]),_._v(" "),e("ol",[e("li",[_._v("打开一条 TCP 连接")]),_._v(" "),e("li",[_._v("发送一个 HTTP 报文（Request）")]),_._v(" "),e("li",[_._v("读取返回的 HTTP 报文（Response）")]),_._v(" "),e("li",[_._v("关闭 TCP 连接")])]),_._v(" "),e("p",[e("strong",[_._v("HTTP 协议本身并不需要其底层的传输层协议是面向连接的")]),_._v("，只需要它是可靠的。由于 TCP 比 UDP 更可靠，所以 HTTP 通常依赖 TCP 进行消息传递，但这不是必须的，像 HTTP/3 就使用了基于 UDP 传输协议改造的 QUIC 协议。")]),_._v(" "),e("h4",{attrs:{id:"短连接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#短连接"}},[_._v("#")]),_._v(" 短连接")]),_._v(" "),e("p",[e("code",[_._v("HTTP/1.0")]),_._v(" 是最早期的模型，只支持短连接。每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 "),e("code",[_._v("TCP")]),_._v(" 握手，而且是连续不断的。")]),_._v(" "),e("p",[_._v("TCP 协议握手会耗费时间，因此其本身具备保持更多的热连接来适应负载的能力。"),e("strong",[_._v("短连接未能充分使用到 TCP 具备的能力")]),_._v("，性能较低。")]),_._v(" "),e("p",[e("img",{attrs:{src:t(475),alt:""}})]),_._v(" "),e("h4",{attrs:{id:"长连接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#长连接"}},[_._v("#")]),_._v(" 长连接")]),_._v(" "),e("p",[_._v("从 HTTP/1.1 开始，连接在完成第三阶段后不再关闭，客户端可以再次发起新的请求。这意味着第二步和第三步可以连续进行数次。")]),_._v(" "),e("p",[_._v("一个长连接会保持一段时间，重复用于发送一系列请求，节省了新建 TCP 连接握手的时间，还可以利用 TCP 的性能增强能力。")]),_._v(" "),e("p",[_._v("不过这个连接也不会一直保留着：连接在空闲一段时间后会被关闭(服务器可以使用 Keep-Alive 协议头来指定一个最小的连接保持时间)。")]),_._v(" "),e("h4",{attrs:{id:"流水线连接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#流水线连接"}},[_._v("#")]),_._v(" 流水线连接")]),_._v(" "),e("p",[_._v("默认情况下，HTTP 请求是按顺序发出的。下一个请求只有在当前请求收到应答过后才会被发出。为了提升请求效率，HTTP/1.1 还支持流水线，即在同一条长连接上发出连续的请求，而不用等待应答返回。这样可以避免连接延迟。理论上讲，性能还会因为两个 HTTP 请求有可能被打包到一个 TCP 消息包中而得到提升。就算 HTTP 请求不断的继续，尺寸会增加，但设置 TCP 的 MSS(Maximum Segment Size) 选项，仍然足够包含一系列简单的请求。")]),_._v(" "),e("blockquote",[e("p",[_._v("HTTP/1.1引入了流水线（被证明难以实现）和持久连接的概念：底层的TCP连接可以通过 "),e("code",[_._v("Connection")]),_._v(" (close/keep-alive)头部来被部分控制。HTTP/2则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。")])]),_._v(" "),e("h3",{attrs:{id:"_1-2-http-报文"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-http-报文"}},[_._v("#")]),_._v(" 1.2 HTTP 报文")]),_._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages",target:"_blank",rel:"noopener noreferrer"}},[_._v("HTTP消息——MDN"),e("OutboundLink")],1)])]),_._v(" "),e("h4",{attrs:{id:"请求报文"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请求报文"}},[_._v("#")]),_._v(" 请求报文")]),_._v(" "),e("p",[e("img",{attrs:{src:t(476),alt:""}})]),_._v(" "),e("h4",{attrs:{id:"响应报文"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#响应报文"}},[_._v("#")]),_._v(" 响应报文")]),_._v(" "),e("p",[e("img",{attrs:{src:t(477),alt:""}})]),_._v(" "),e("h3",{attrs:{id:"_1-3-无状态-与-cookie"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-无状态-与-cookie"}},[_._v("#")]),_._v(" 1.3 无状态 与 cookie")]),_._v(" "),e("p",[_._v("HTTP 无状态的意思是指："),e("strong",[_._v("在同一个连接中，两个执行成功的请求之间是没有关系的。")])]),_._v(" "),e("p",[_._v("这就带来了一个问题，"),e("strong",[_._v("用户没有办法在同一个网站中进行连续的交互")]),_._v("。比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。")]),_._v(" "),e("p",[_._v("通过在 HTTP 协议的头部添加 Cookies 字段可以解决这个问题。")]),_._v(" "),e("h4",{attrs:{id:"常见头部字段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见头部字段"}},[_._v("#")]),_._v(" 常见头部字段")]),_._v(" "),e("ul",[e("li",[e("strong",[_._v("Set-Cookie")]),_._v("，服务器通过该头部告知客户端保存 Cookie 信息。\n"),e("ul",[e("li",[e("code",[_._v("<cookie名>=<cookie值>")]),_._v(" :(可设置多条)")]),_._v(" "),e("li",[e("code",[_._v("Secure")]),_._v(" : 标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端")]),_._v(" "),e("li",[e("code",[_._v("HttpOnly")]),_._v(" ：无法被 JS 脚本访问，此类 Cookie 仅作用于服务器")]),_._v(" "),e("li",[e("code",[_._v("SameSite=Strict/None/Lax")]),_._v(" :允许服务器要求某个 cookie 在跨站请求时不会被发送，从而阻止 CSRF 。")])])]),_._v(" "),e("li",[e("strong",[_._v("Cookie")]),_._v("，每次发请求时，浏览器会自动携带 Cookie 头部")])]),_._v(" "),e("blockquote",[e("p",[_._v("Cookie 生命周期")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("会话期 Cookie 是最简单的 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期Cookie不需要指定过期时间（Expires）或者有效期（Max-Age）。")])]),_._v(" "),e("li",[e("p",[_._v("持久性 Cookie 的生命周期取决于过期时间（Expires）或有效期（Max-Age）指定的一段时间。")])])])]),_._v(" "),e("h3",{attrs:{id:"_1-4-跨域与-cors"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-跨域与-cors"}},[_._v("#")]),_._v(" 1.4 跨域与 CORS")]),_._v(" "),e("h4",{attrs:{id:"相关字段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#相关字段"}},[_._v("#")]),_._v(" 相关字段")]),_._v(" "),e("ul",[e("li",[e("strong",[_._v("Origin")]),_._v(" "),e("ul",[e("li",[_._v("请求头字段，指示了请求来自于哪个站点")]),_._v(" "),e("li",[_._v("该字段仅指示站点的服务器名称，并不包含任何路径信息")]),_._v(" "),e("li",[_._v("无需手动设置，当开发者使用 XMLHttpRequest 对象发起跨源请求时，它们已经被设置就绪")])])]),_._v(" "),e("li",[e("strong",[_._v("Access-Control-Allow-Origin")]),_._v(" "),e("ul",[e("li",[_._v("响应头字段，指定了该响应的资源是否被允许与给定的 origin 共享")]),_._v(" "),e("li",[_._v("指定域名或 *")])])])]),_._v(" "),e("p",[_._v("组合使用 "),e("code",[_._v("Origin")]),_._v(" 和 "),e("code",[_._v("Access-Control-Allow-Origin")]),_._v(" 就能完成简单的访问控制：")]),_._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# 指定域名")]),_._v("\nOrigin ： http://foo.example\nAccess-Control-Allow-Origin "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[_._v(":")]),_._v(" http://foo.example\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# 允许所有跨域")]),_._v("\nAccess-Control-Allow-Origin ：*\n")])]),_._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[_._v("1")]),e("br"),e("span",{staticClass:"line-number"},[_._v("2")]),e("br"),e("span",{staticClass:"line-number"},[_._v("3")]),e("br"),e("span",{staticClass:"line-number"},[_._v("4")]),e("br"),e("span",{staticClass:"line-number"},[_._v("5")]),e("br"),e("span",{staticClass:"line-number"},[_._v("6")]),e("br")])]),e("h3",{attrs:{id:"_1-5-代理与缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-代理与缓存"}},[_._v("#")]),_._v(" 1.5 代理与缓存")]),_._v(" "),e("p",[_._v("在浏览器和服务器之间，有许多计算机和其他设备转发了 HTTP 消息。虽然它们可能会对应用层性能有重要影响，但对于 HTTP 应用层而言就是透明的。")]),_._v(" "),e("p",[_._v("在应用层上的转发被称为代理（Proxies）。代理（Proxies）既可以表现得透明（只是转发），又可以不透明（转发前改变请求）。代理有如下几种作用：")]),_._v(" "),e("ul",[e("li",[e("strong",[_._v("缓存")]),_._v("（可以是公开的也可以是私有的，像浏览器的缓存）")]),_._v(" "),e("li",[_._v("过滤（像反病毒扫描，家长控制...）")]),_._v(" "),e("li",[_._v("负载均衡（让多个服务器服务不同的请求）")]),_._v(" "),e("li",[_._v("认证（对不同资源进行权限管理）")]),_._v(" "),e("li",[_._v("日志记录（允许存储历史信息）")])]),_._v(" "),e("h4",{attrs:{id:"缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[_._v("#")]),_._v(" 缓存")]),_._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"https://www.jianshu.com/p/9c95db596df5",target:"_blank",rel:"noopener noreferrer"}},[_._v("彻底弄懂强缓存与协商缓存——简书"),e("OutboundLink")],1)])]),_._v(" "),e("p",[_._v("缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。"),e("strong",[_._v("当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。")])]),_._v(" "),e("p",[_._v("缓存的关键主要包括请求方法和请求 URI（"),e("strong",[_._v("一般只有 GET 请求才会被缓存")]),_._v("）。")]),_._v(" "),e("h4",{attrs:{id:"缓存场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存场景"}},[_._v("#")]),_._v(" 缓存场景")]),_._v(" "),e("ul",[e("li",[_._v("一个检索请求的成功响应: 状态码 200")]),_._v(" "),e("li",[_._v("永久重定向: 响应状态码 301")]),_._v(" "),e("li",[_._v("错误响应: 响应状态码 404")]),_._v(" "),e("li",[_._v("不完全的响应: 响应状态码 206，只返回局部的信息")]),_._v(" "),e("li",[_._v("除了 GET 请求外，如果匹配到作为一个已被定义的 cache 键名的响应 ？？？")])]),_._v(" "),e("h4",{attrs:{id:"协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[_._v("#")]),_._v(" 协商缓存")]),_._v(" "),e("p",[_._v("缓存分为强缓存和协商缓存。在过期时间之前，直接使用缓存资源（即强缓存）。过期后不会立即清除，而是先发送包含比较头部的请求到服务器，服务器判断是否可用（即协商缓存）.")]),_._v(" "),e("p",[e("img",{attrs:{src:t(478),alt:""}})]),_._v(" "),e("ul",[e("li",[e("strong",[_._v("Cache-control")]),_._v(" "),e("ul",[e("li",[_._v("no-store : 没有缓存")]),_._v(" "),e("li",[_._v("no-cache ：缓存但重新验证")]),_._v(" "),e("li",[_._v("public ：公共缓存（中间人均可缓存）")]),_._v(" "),e("li",[_._v("private ：私有缓存（针对单个用户，中间人不得缓存）")]),_._v(" "),e("li",[_._v("max-age=12312 ：过期时间（相对于请求发起的时间，单位为秒）")]),_._v(" "),e("li",[_._v("must-revalidate ：校验方式（缓存在考虑使用一个陈旧资源，必须先验证其状态）")])])]),_._v(" "),e("li",[e("strong",[_._v("Expires")]),_._v(" "),e("ul",[e("li",[_._v("过期时间，在此时间之后（比较 Date 头部，该通用头部包含了报文创建的日期和时间），响应资源过期")]),_._v(" "),e("li",[_._v("如果 Cache-Control 设置了 max-age 指令，则 Expires 会被忽略")]),_._v(" "),e("li",[_._v("它是在 Cache-control 之前控制强缓存的协议头")]),_._v(" "),e("li",[e("code",[_._v("<http-date>")])])])]),_._v(" "),e("li",[e("strong",[_._v("ETag")]),_._v(" "),e("ul",[e("li",[_._v("资源的特定版本的标识符，类似文件指纹，比较 Etags 能快速确定此资源是否变化")]),_._v(" "),e("li",[_._v("如果给定URL中的资源更改，则一定要生成新的 Etag 值")]),_._v(" "),e("li",[_._v("使用"),e("strong",[_._v("强比较算法")]),_._v("，即只有在每一个字节都相同的情况下，才可以认为两个文件是相同的")]),_._v(" "),e("li",[_._v("配合 "),e("code",[_._v("If-Match")]),_._v(" 进行缓存校验")])])]),_._v(" "),e("li",[e("strong",[_._v("If-Match/If-Not-Match")]),_._v(" "),e("ul",[e("li",[_._v("表示这是一个条件请求。在请求方法为 GET 和 HEAD 的情况下，服务器仅在请求的资源满足此首部列出的 ETag 值时才会返回资源")]),_._v(" "),e("li",[e("code",[_._v("<etag_value>, <etag_value>, …")])])])]),_._v(" "),e("li",[e("strong",[_._v("Last-Modified")]),_._v(" "),e("ul",[e("li",[_._v("包含源头服务器认定的资源作出修改的日期及时间")]),_._v(" "),e("li",[_._v("配合 "),e("code",[_._v("If-Modified-Since")]),_._v(" 进行缓存验证")]),_._v(" "),e("li",[_._v("其精度比 "),e("code",[_._v("ETag")]),_._v(" 低（只能精确到一秒），是备用机制")])])]),_._v(" "),e("li",[e("strong",[_._v("If-Modified-Since")]),_._v(" "),e("ul",[e("li",[_._v("条件式请求头，服务器在给定日期之后有修改时才返回最新资源")]),_._v(" "),e("li",[_._v("与 "),e("code",[_._v("If-None-Match")]),_._v(" 一同出现时，会被忽略掉")])])]),_._v(" "),e("li",[e("strong",[_._v("Vary")]),_._v(" "),e("ul",[e("li",[_._v("逗号分隔的一系列 http 头部名称，用于确定缓存是否可用。")]),_._v(" "),e("li",[_._v("缓存服务器收到请求时，只有当前的请求和缓存的请求头跟缓存的响应头里的Vary都匹配，才能使用缓存的响应")]),_._v(" "),e("li",[_._v("Vary: "),e("code",[_._v("<header-name>, <header-name>, ...")])])])])]),_._v(" "),e("h4",{attrs:{id:"cache-control-与-expires-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cache-control-与-expires-的区别"}},[_._v("#")]),_._v(" Cache-control 与 Expires 的区别")]),_._v(" "),e("p",[_._v("Expires 指定的是具体日期，在该日期之前缓存有效。而 Cache-control 的 max-age 指定的是有效时长，从请求开始到 max-age 之间缓存有效。")]),_._v(" "),e("p",[e("font",{attrs:{color:"red"}},[_._v("关键性的区别在于，"),e("strong",[_._v("使用 Expires 需要保证服务器和客户端的时钟严格同步")]),_._v("，而  Cache-control 的 max-age 没有这个限制")]),_._v("。")],1),_._v(" "),e("p",[e("img",{attrs:{src:t(479),alt:""}})]),_._v(" "),e("h3",{attrs:{id:"_1-6-http-状态码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-http-状态码"}},[_._v("#")]),_._v(" 1.6 HTTP "),e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status",target:"_blank",rel:"noopener noreferrer"}},[_._v("状态码"),e("OutboundLink")],1)]),_._v(" "),e("p",[_._v("客户端的每次请求，服务器都必须予以回应，回应包括"),e("strong",[_._v("HTTP状态码")]),_._v("和"),e("strong",[_._v("数据")]),_._v("两部分。HTTP 状态码是一个三位数，分为五类：")]),_._v(" "),e("ul",[e("li",[_._v("1xx  相关信息")]),_._v(" "),e("li",[_._v("2xx  "),e("strong",[_._v("操作成功")]),_._v(" "),e("ul",[e("li",[_._v("200 成功，包含网页内容，可缓存")]),_._v(" "),e("li",[_._v("204 响应成功，但是无返回值")])])]),_._v(" "),e("li",[_._v("3xx  重定向\n"),e("ul",[e("li",[_._v("301 永久移动，请求的网页已移动到新的位置，自动将请求者转到新位置")]),_._v(" "),e("li",[_._v("302 历史移动，暂时移动到新位置，后续应继续使用当前位置")]),_._v(" "),e("li",[_._v("304 内容未修改，不返回内容（可使用缓存）")])])]),_._v(" "),e("li",[_._v("4xx  "),e("strong",[_._v("客户端错误")]),_._v(" "),e("ul",[e("li",[_._v("400 请求参数有误")]),_._v(" "),e("li",[_._v("401 需要用户验证")]),_._v(" "),e("li",[_._v("403 服务器拒绝执行")]),_._v(" "),e("li",[_._v("404 服务器没有该资源")])])]),_._v(" "),e("li",[_._v("5xx  "),e("strong",[_._v("服务器错误")])])]),_._v(" "),e("h3",{attrs:{id:"附-使用-js-发送请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#附-使用-js-发送请求"}},[_._v("#")]),_._v(" 附：使用 JS 发送请求")]),_._v(" "),e("ul",[e("li",[e("strong",[_._v("原生")]),_._v(" "),e("ul",[e("li",[_._v("XMLHTTPRequest")]),_._v(" "),e("li",[_._v("Fetch")])])]),_._v(" "),e("li",[e("strong",[_._v("第三方库")]),_._v(" "),e("ul",[e("li",[_._v("axios")]),_._v(" "),e("li",[_._v("ajax")])])]),_._v(" "),e("li",[e("strong",[_._v("服务端消息推送")]),_._v(" "),e("ul",[e("li",[_._v("EventSource")]),_._v(" "),e("li",[e("a",{attrs:{href:"https://www.jianshu.com/p/958eba34a5da",target:"_blank",rel:"noopener noreferrer"}},[_._v("利用WebSocket和EventSource实现服务端推送"),e("OutboundLink")],1)])])])]),_._v(" "),e("h2",{attrs:{id:"_2-https-协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-https-协议"}},[_._v("#")]),_._v(" 2. HTTPS 协议")]),_._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"https://www.runoob.com/w3cnote/https-ssl-intro.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("HTTPS 与 SSL 证书概要——菜鸟教程"),e("OutboundLink")],1)])]),_._v(" "),e("p",[e("code",[_._v("HTTP")]),_._v(" 协议是明文传输， "),e("code",[_._v("HTTPS")]),_._v(" 在 "),e("code",[_._v("HTTP")]),_._v(" 与 "),e("code",[_._v("TCP")]),_._v(" 之间增加了一层安全协议（"),e("code",[_._v("SSL")]),_._v("）来对信息进行加密，通过"),e("strong",[_._v("提供对网络服务器的身份认证")]),_._v("，保护了数据隐私与完整性。")]),_._v(" "),e("p",[_._v("两个作用："),e("strong",[_._v("服务器身份认证、传输加密")]),_._v("。")]),_._v(" "),e("p",[e("code",[_._v("HTTPS")]),_._v(" 在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在"),e("strong",[_._v("握手过程中确立双方加密传输数据的密码信息")]),_._v("。")]),_._v(" "),e("h3",{attrs:{id:"_2-1-https-通信步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-https-通信步骤"}},[_._v("#")]),_._v(" 2.1 HTTPS 通信步骤")]),_._v(" "),e("p",[e("img",{attrs:{src:t(480),alt:""}})]),_._v(" "),e("ol",[e("li",[_._v("浏览器\n"),e("ul",[e("li",[_._v("将自己支持的一套"),e("code",[_._v("加密规则")]),_._v("发送给网站")])])]),_._v(" "),e("li",[_._v("网站\n"),e("ul",[e("li",[_._v("从中选出一组"),e("code",[_._v("加密算法")]),_._v("与 "),e("code",[_._v("HASH 算法")])]),_._v(" "),e("li",[_._v("将自己的身份信息以证书的形式发回给浏览器")]),_._v(" "),e("li",[_._v("证书包含了网站地址、"),e("code",[_._v("加密公钥")]),_._v("（"),e("strong",[_._v("非对称加密")]),_._v("）、颁发机构等信息")])])]),_._v(" "),e("li",[_._v("浏览器\n"),e("ol",[e("li",[_._v("验证证书的合法性（"),e("strong",[_._v("身份认证")]),_._v("）\n"),e("ul",[e("li",[_._v("颁发证书的机构是否合法")]),_._v(" "),e("li",[_._v("证书中包含的网站地址是否与正在访问的地址一致")])])]),_._v(" "),e("li",[_._v("生成一串随机数密码，并用"),e("code",[_._v("加密公钥")]),_._v("加密（"),e("strong",[_._v("传输加密")]),_._v("）")]),_._v(" "),e("li",[_._v("使用约定好的 "),e("code",[_._v("HASH 算法")]),_._v(" 计算握手消息，并使用"),e("code",[_._v("随机数密码")]),_._v("（"),e("strong",[_._v("对称加密")]),_._v("）对消息进行加密")]),_._v(" "),e("li",[_._v("将之前生成的所有信息发送给网站")])])]),_._v(" "),e("li",[_._v("网站\n"),e("ol",[e("li",[_._v("使用"),e("code",[_._v("私钥")]),_._v("将信息解密取出"),e("code",[_._v("随机数密码")])]),_._v(" "),e("li",[_._v("使用"),e("code",[_._v("随机数密码")]),_._v("解密握手消息")]),_._v(" "),e("li",[_._v("验证 HASH 是否与浏览器发来的一致")]),_._v(" "),e("li",[_._v("使用"),e("code",[_._v("随机数密码")]),_._v("加密一段握手消息，发送给浏览器")])])]),_._v(" "),e("li",[_._v("浏览器\n"),e("ul",[e("li",[_._v("使用"),e("code",[_._v("随机数密码")]),_._v("解密并计算握手消息的 HASH")]),_._v(" "),e("li",[_._v("如果与服务端发来的 HASH 一致，握手过程结束")])])]),_._v(" "),e("li",[e("strong",[_._v("后续的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密")])])]),_._v(" "),e("p",[e("strong",[_._v("浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常地加密解密数据，为后续真正数据的传输做一次测试。")])]),_._v(" "),e("h3",{attrs:{id:"_2-2-https-是对称加密与非对称加密搭配使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-https-是对称加密与非对称加密搭配使用"}},[_._v("#")]),_._v(" 2.2 HTTPS 是对称加密与非对称加密搭配使用")]),_._v(" "),e("p",[_._v("由上述步骤可以看出，在验证服务器身份时，使用的是非对称加密：")]),_._v(" "),e("ol",[e("li",[_._v("服务器告知浏览器 "),e("code",[_._v("公钥")])]),_._v(" "),e("li",[_._v("浏览器使用 "),e("code",[_._v("公钥")]),_._v(" 加密信息")]),_._v(" "),e("li",[_._v("服务器使用 "),e("code",[_._v("私钥")]),_._v(" 解密信息")])]),_._v(" "),e("p",[_._v("而在数据传输阶段使用的是对称加密：")]),_._v(" "),e("ol",[e("li",[_._v("浏览器使用服务器 "),e("code",[_._v("公钥")]),_._v(" 加密并发送 "),e("code",[_._v("对称密钥")])]),_._v(" "),e("li",[_._v("服务器使用 "),e("code",[_._v("私钥")]),_._v(" 解密获取 "),e("code",[_._v("对称密钥")])]),_._v(" "),e("li",[_._v("握手完成")]),_._v(" "),e("li",[_._v("浏览器和服务器均使用 "),e("code",[_._v("对称密钥")]),_._v(" 进行业务信息的传输")])]),_._v(" "),e("p",[e("strong",[_._v("搞这么复杂最主要的原因是：")])]),_._v(" "),e("ol",[e("li",[e("strong",[_._v("安全性")]),_._v("：两边需要使用相同的密钥，需要使用一种安全的方式交换密钥，单纯使用对称加密，无法实现密钥交换")]),_._v(" "),e("li",[e("strong",[_._v("传输效率")]),_._v("：只使用非对称加密是可以满足安全性要求的，但是相同加密级别下，非对称加密的计算耗时高于对称加密的 2-3 个数量级")])]),_._v(" "),e("h3",{attrs:{id:"_2-3-ssl-证书"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-ssl-证书"}},[_._v("#")]),_._v(" 2.3 SSL 证书")]),_._v(" "),e("p",[_._v("SSL 证书通常由 CA 机构颁发，以"),e("strong",[_._v("验证网站身份")]),_._v("和加密数据。如果\b只是个人网站出于"),e("strong",[_._v("加密传输")]),_._v("的需要，也可以自行制作 SSL 证书，但浏览器会提示「证书不受信任」。")]),_._v(" "),e("h4",{attrs:{id:"_2-3-1-证书链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-1-证书链"}},[_._v("#")]),_._v(" 2.3.1 证书链")]),_._v(" "),e("p",[_._v("SSL 证书以证书链的形式组织，首先要有根 CA 机构颁发的根证书，再由根 CA 机构颁发一个中级 CA 机构的证书，最后由中级 CA 机构颁发具体的 SSL 证书，这三级证书形成一条证书链。")]),_._v(" "),e("p",[_._v("根证书：")]),_._v(" "),e("p",[e("img",{attrs:{src:t(481),alt:""}})]),_._v(" "),e("p",[_._v("中级证书：")]),_._v(" "),e("p",[e("img",{attrs:{src:t(482),alt:""}})]),_._v(" "),e("p",[_._v("SSL 证书：")]),_._v(" "),e("p",[e("img",{attrs:{src:t(483),alt:""}})]),_._v(" "),e("h4",{attrs:{id:"_2-3-2-验证过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-验证过程"}},[_._v("#")]),_._v(" 2.3.2 验证过程")]),_._v(" "),e("p",[_._v("浏览器的验证过程也是沿着路径一级级验证：")]),_._v(" "),e("ol",[e("li",[e("strong",[_._v("验证根 CA 证书")]),_._v(" "),e("ul",[e("li",[_._v("如果根证书不受信任，其下所有证书都不受信任")]),_._v(" "),e("li",[_._v("根 CA 机构证书在操作系统安装过程中默认安装一些")])])]),_._v(" "),e("li",[e("strong",[_._v("验证中级证书")]),_._v(" "),e("ul",[e("li",[_._v("不同中级机构负责颁发不同类型的证书")])])]),_._v(" "),e("li",[e("strong",[_._v("验证 SSL 证书")])])]),_._v(" "),e("h2",{attrs:{id:"_3-http-2-协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-http-2-协议"}},[_._v("#")]),_._v(" 3. HTTP/2 协议")]),_._v(" "),e("p",[_._v("HTTP 协议第一个主要版本为 "),e("code",[_._v("HTTP/1.1")]),_._v(" ， 2.0 版本的协议于 2015年5月 发布，被多数浏览器所支持。截至2019年，已有 36% 的网站支持 "),e("code",[_._v("HTTP/2")]),_._v(" 。 "),e("code",[_._v("HTTP/2")]),_._v(" 保留了 "),e("code",[_._v("HTTP/1.1")]),_._v(" 的大部分语义，采用了新的方式进行编码和传输，速度上得到很大提升（查看两种请求的速度差异 "),e("a",{attrs:{href:"https://http2.akamai.com/demo",target:"_blank",rel:"noopener noreferrer"}},[_._v("demo"),e("OutboundLink")],1),_._v("）。")]),_._v(" "),e("p",[e("code",[_._v("HTTP/1.x")]),_._v(" 报文有一些性能上的缺点：")]),_._v(" "),e("ul",[e("li",[_._v("Header 不像 body，它不会被压缩。")]),_._v(" "),e("li",[_._v("两个报文之间的 header 通常非常相似，但它们仍然在连接中重复传输。")]),_._v(" "),e("li",[_._v("无法复用。当在同一个服务器打开几个连接时：TCP 热连接比冷连接更加有效。")])]),_._v(" "),e("p",[e("code",[_._v("HTTP/2")]),_._v("在"),e("code",[_._v("HTTP/1.1")]),_._v("有几处基本的不同:")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("HTTP/2")]),_._v(" 是二进制协议\n"),e("ul",[e("li",[_._v("不再可读")]),_._v(" "),e("li",[_._v("不可无障碍的手动创建")])])]),_._v(" "),e("li",[_._v("多路复用\n"),e("ul",[e("li",[_._v("移除了 "),e("code",[_._v("HTTP/1.x")]),_._v(" 中顺序和阻塞的约束")]),_._v(" "),e("li",[_._v("并行的请求能在同一个链接中处理")])])]),_._v(" "),e("li",[_._v("头部压缩\n"),e("ul",[e("li",[_._v("headers 在一系列请求中常常是相似的")])])]),_._v(" "),e("li",[_._v("允许服务器在客户端缓存中填充数据\n"),e("ul",[e("li",[_._v("通过"),e("strong",[_._v("服务器推送机制")]),_._v("来提前请求")]),_._v(" "),e("li",[_._v("客户端有权力选择是否接收")])])])]),_._v(" "),e("h3",{attrs:{id:"_3-1-多路复用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-多路复用"}},[_._v("#")]),_._v(" 3.1 多路复用")]),_._v(" "),e("p",[_._v("多路复用是 HTTP2 最强大的特性 ，能够将多条请求在一条 TCP 连接上同时发出去。")]),_._v(" "),e("h3",{attrs:{id:"_3-2-缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-缺点"}},[_._v("#")]),_._v(" 3.2 缺点")]),_._v(" "),e("p",[e("strong",[_._v("队头阻塞")]),_._v("：HTTP2.0协议的多路复用机制解决了HTTP层的队头阻塞问题，但是在 TCP 层仍然存在队头阻塞问题。")]),_._v(" "),e("p",[_._v("因为 TCP 协议在收到数据包之后，这部分数据可能是乱序到达的，但是 TCP 必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。")]),_._v(" "),e("p",[_._v("由于 HTTP2 强制使用 TLS，还存在一个 TLS 协议层面的队头阻塞。")]),_._v(" "),e("h2",{attrs:{id:"_4-http-3-协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-http-3-协议"}},[_._v("#")]),_._v(" 4. HTTP/3 协议")]),_._v(" "),e("p",[_._v("HTTP/3 弃用了 TCP 协议，而改用基于 UDP 的 "),e("RouterLink",{attrs:{to:"/network/3.传输层协议.html#quic-协议"}},[_._v("QUIC")]),_._v(" 协议。")],1),_._v(" "),e("p",[e("img",{attrs:{src:t(484),alt:""}})])])}),[],!1,null,null,null);v.default=s.exports}}]);